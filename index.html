<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>canvas titles</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/blood.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-transition="fade-in slide-in">
					<h3>&lt;canvas&gt;</h3>
					<aside class="notes">
						Hello everyone. Today we would talk about canvas - what is that and how we can use it.
						The Canvas API provides a means for drawing graphics via JavaScript and the HTML canvas element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing.
					</aside>
				</section>
				<section data-transition="fade-in slide-in">
					<section data-transition="convex"><h3>Basic things</h3></section>
					<section data-transition="convex">
						<pre><code data-trim data-noescape>
							&lt;canvas id="canvas"&gt;&lt;/canvas&gt;
						</code></pre>
						<canvas class="canvas" width="300" height="150"></canvas>
						<aside class="notes">
							All we need its just add canvas element to our code
							When no width and height attributes are specified, the canvas will initially be 300 pixels wide and 150 pixels high. But custom sizes can be defined using the HTML height and width property.
							The canvas is initially blank. To display something, a script first needs to access the rendering context and draw on it.
						</aside>
					</section>
					<section data-transition="convex">
						<pre><code data-trim data-noescape>
							const canvas = document.getElementById('canvas');
							const context = canvas.getContext('2d');

							context.fillStyle = "blue";
							context.fillRect(10, 10, 100, 50);
							context.fillStyle = "yellow";
							context.fillRect(10, 60, 150, 50);
						</code></pre>
						<canvas id="first" class="canvas" width="860" height="150"></canvas>
						<aside class="notes">
							The first line in the script retrieves the node in the DOM representing the canvas element by calling the document.getElementById() method. Once you have the element node, you can access the drawing context using its getContext() method. This method takes one parameter, the type of context. For 2D graphics, we need to specify "2d".
							canvas only supports two primitive shapes: rectangles and paths. 
							So lets look what we have here:
							fillRect - this function draws a filled rectangle, with some parameters - x and y specify the position on the canvas of the top-left corner of the rectangle. width and height provide the rectangle's size;
							fillStyle - this propertie sets the style used when filling shapes.
						</aside>
					</section>
					<section data-transition="convex">
						<pre><code data-trim data-noescape>
							context.fillRect(25, 25, 100, 100);
							context.clearRect(45, 45, 60, 60);
							context.strokeRect(50, 50, 50, 50);
						</code></pre>
						<canvas id="second" class="canvas" width="860" height="150"></canvas>
						<aside class="notes">
							Also we have two more functions to draw rectangles shapes:
							clearRect - clears the specified rectangular area, making it fully transparent;
							strokeRect - draws a rectangular outline.
							Each of these functions takes the same parameters as below
						</aside>
					</section>
					<section data-transition="convex">
						<pre><code data-trim data-noescape>
							context.fillStyle = "#025402";
							context.beginPath();
							context.moveTo(100, 25);
							context.lineTo(50, 75);
							context.lineTo(150, 75);
							context.fill();

							context.strokeStyle = "#540249";
							context.beginPath();
							context.moveTo(300, 25);
							context.lineTo(250, 75);
							context.lineTo(350, 75);
							context.closePath();
							context.stroke();
						</code></pre>
						<canvas id="third" class="canvas" width="860" height="150"></canvas>
						<aside class="notes">
							Now let's look at paths and lines. A path is a list of points, connected by segments of lines that can be of different shapes, curved or not, of different width and of different color. A path, or even a subpath, can be closed. To make shapes using paths, we take some extra steps:
							First of all, you need to create the path with beginPath function.
							Then you use drawing commands to draw into the path:
							moveTo - moves the pen to the coordinates specified by x and y;
							lineTo - draws a line from the current drawing position to the specified position;
							Once the path has been created, you can stroke or fill the path to render it.
							You'll notice the difference between the filled and stroked triangle. This is, as mentioned above, because shapes are automatically closed when a path is filled, but not when they are stroked. If we left out the closePath for the stroked triangle, only two lines would have been drawn, not a complete triangle.
						</aside>
					</section>
					<section data-transition="convex">
						<pre><code data-trim data-noescape>
							context.beginPath();
							context.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
							context.moveTo(110, 75);
							context.arc(75, 75, 35, 0, Math.PI, false);  // Mouth (clockwise)
							context.moveTo(65, 65);
							context.arc(60, 65, 5, 0, Math.PI * 2, true);  // Left eye
							context.moveTo(95, 65);
							context.arc(90, 65, 5, 0, Math.PI * 2, true);  // Right eye
							context.stroke();
						</code></pre>
						<canvas id="fourth" class="canvas" width="860" height="150"></canvas>
						<aside class="notes">
							To draw arcs or circles, we use the arc method which takes six parameters: x and y are the coordinates of the center of the circle on which the arc should be drawn. The arc's radius. Must be positive. The startAngle and endAngle parameters define the start and end points of the arc in radians, along the curve of the circle. These are measured from the x axis. The counterclockwise parameter is An optional boolean value. If true, draws the arc counter-clockwise between the start and end angles. The default is false (clockwise).
						</aside>
					</section>
				</section>
				<section data-transition="fade-in slide-in">
					<section data-transition="convex"><h3>Animation</h3></section>
					<section data-transition="convex">
						<pre><code data-trim data-noescape>
							const context = document.getElementById('canvas').getContext('2d');
							let angle = 0;
							requestAnimationFrame(draw);

							function draw () {
								context.clearRect(0, 0, 300, 150);
								let x = Math.sin(angle);
								let y = Math.cos(angle);
								context.beginPath();
								context.arc(150, 75, 20, 0, Math.PI * 2);
								context.arc(150 + x * 60, 75 + y * 60, 5, 0, Math.PI * 2);
								context.fillStyle = '#188ad0';
								context.fill();
								requestAnimationFrame(draw);
								angle += 0.01;
							}
						</code></pre>
						<canvas id="five" class="canvas" width="300" height="150"></canvas>
						<aside class="notes">
							Since we're using JavaScript to control canvas elements, it's also very easy to make animations.
							These are the steps you need to take to draw a frame:
							1. Clear the canvas Unless the shapes you'll be drawing fill the complete canvas (for instance a backdrop image), you need to clear any shapes that have been drawn previously. The easiest way to do this is using the clearRect() method.
							2. Save the canvas state If you're changing any setting (such as styles, transformations, etc.) which affect the canvas state and you want to make sure the original state is used each time a frame is drawn, you need to save that original state.
							3. Draw animated shapes The step where you do the actual frame rendering.
							4. Restore the canvas state If you've saved the state, restore it before drawing a new frame.
							Shapes are drawn to the canvas by using the canvas methods directly or by calling custom functions. In normal circumstances, we only see these results appear on the canvas when the script finishes executing. For instance, it isn't possible to do an animation from within a for loop.
							That means we need a way to execute our drawing functions over a period of time. To control an animation we will use requestAnimationFrame method which tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.
						</aside>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
		<script src="./canvas.js"></script>
	</body>
</html>
